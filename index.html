<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hidden Dragon Chess II: The Rise of the Archer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
        }
        #game-container {
            position: relative;
        }
        .piece {
            -webkit-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }
        .red-piece {
            color: #c0392b;
        }
        .black-piece {
            color: #2c3e50;
        }
        .valid-move::after {
            content: '';
            position: absolute;
            width: 20px;
            height: 20px;
            background-color: rgba(46, 204, 113, 0.7);
            border-radius: 50%;
        }
    </style>
</head>
<body class="bg-[#5a3a22] text-[#f0e2d0] flex justify-center items-center min-h-screen p-4">
<div id="game-container" class="flex flex-col items-center text-center">
    <h1 class="text-2xl md:text-4xl font-bold mb-4 text-white" style="text-shadow: 2px 2px 4px #000;">Hidden Dragon Chess II: The Rise of the Archer</h1>
    
    <div id="chess-board" class="grid grid-cols-8 grid-rows-4 bg-[#e3b778] border-4 border-[#3d281a] gap-1 p-2 relative shadow-2xl">
        <!-- Squares will be generated by JavaScript -->
    </div>

    <!-- Overlays -->
    <div id="pregame-overlay" class="absolute inset-0 bg-black bg-opacity-70 flex items-center justify-center flex-col z-20">
        <h2 class="text-4xl font-bold text-white mb-8">Who will play first?</h2>
        <div class="flex gap-8">
            <button id="human-first-btn" class="px-8 py-4 text-2xl bg-blue-600 hover:bg-blue-700 text-white font-bold rounded-lg">Human First</button>
            <button id="ai-first-btn" class="px-8 py-4 text-2xl bg-red-600 hover:bg-red-700 text-white font-bold rounded-lg">AI First</button>
        </div>
    </div>
    <div id="winner-overlay" class="absolute inset-0 bg-black bg-opacity-60 hidden items-center justify-center flex-col z-10 cursor-pointer">
        <h2 id="winner-text" class="text-4xl md:text-6xl font-bold text-center" style="text-shadow: 3px 3px 8px rgba(0,0,0,0.8);"></h2>
    </div>

    <div id="info-panel" class="flex flex-col md:flex-row justify-around w-full max-w-4xl mt-5 gap-4">
        <div id="player1-info" class="w-full md:w-64 p-3 border-2 border-[#f0e2d0] rounded-lg">
            <h3 id="p1-title">Player 1 (Human)</h3>
            <p id="player1-score">Score: 0</p>
        </div>
        <div id="player2-info" class="w-full md:w-64 p-3 border-2 border-[#f0e2d0] rounded-lg">
            <h3 id="p2-title">Player 2 (AI)</h3>
            <p id="player2-score">Score: 0</p>
        </div>
    </div>
    <p id="game-status" class="text-lg font-bold h-12 mt-2"></p>
    <p id="game-over" class="text-xl text-[#e74c3c] font-bold"></p>
    <button id="reset-button" class="mt-4 px-5 py-2 text-lg cursor-pointer border-none rounded-md bg-[#2e4a60] text-white hover:bg-[#4a779c]">New Game</button>
</div>

<script>
    // ===================================================================================
    // GAME ENGINE (The "Brain")
    // ===================================================================================
    class HiddenDragonGame {
        constructor() {
            this.COLS = 8;
            this.ROWS = 4;
            this.SQUARES = this.COLS * this.ROWS;
            this.scores = { 'k': 10, 'r': 12, 'c': 8, 'h': 7, 'w': 6, 'e': 5, 'a': 4, 's': 3 };
            this.reset();
        }

        reset() {
            const redPieces = ['R','H','E','A','K','A','E','H','R','C','C','S','S','S','S','W'];
            const blackPieces = redPieces.map(p => p.toLowerCase());
            const allPieces = [...redPieces, ...blackPieces];
            
            for (let i = allPieces.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [allPieces[i], allPieces[j]] = [allPieces[j], allPieces[i]];
            }

            this.board = allPieces.map(p => ({ piece: p, isFlipped: false }));
            this.isGameStarted = false;
            this.isGameOver = false;
            this.humanPlayerColor = null;
            this.isRedTurn = true;
            this.lastMove = { red: null, black: null };
            this.scores.red = 0;
            this.scores.black = 0;
        }

        isRedPiece(piece) {
            return piece && piece.toUpperCase() === piece;
        }

        isPieceOfCurrentTurn(piece) {
            if (!piece) return false;
            return this.isRedTurn === this.isRedPiece(piece);
        }

        handleFirstFlip(index, firstPlayerIsHuman) {
            const cell = this.board[index];
            if (!cell.piece) return null;

            cell.isFlipped = true;
            this.isGameStarted = true;

            const revealedColorIsRed = this.isRedPiece(cell.piece);
            
            if (firstPlayerIsHuman) {
                this.humanPlayerColor = revealedColorIsRed ? 'red' : 'black';
            } else {
                this.humanPlayerColor = revealedColorIsRed ? 'black' : 'red';
            }
            
            this.isRedTurn = revealedColorIsRed;
            this.switchTurn();
            return { type: 'flip', from: index, to: index };
        }
        
        handleFlip(index) {
            const cell = this.board[index];
            if (cell.isFlipped) return null;
            cell.isFlipped = true;
            this.switchTurn();
            return { type: 'flip', from: index, to: index };
        }

        handleMove(from, to) {
            if (!this.getValidMoves(this.board, this.board[from].piece, from).includes(to)) {
                return null;
            }
            
            const currentMove = { from, to, piece: this.board[from].piece };
            const lastPlayerMove = this.isRedTurn ? this.lastMove.red : this.lastMove.black;
            
            if (lastPlayerMove && lastPlayerMove.from === to && lastPlayerMove.to === from && lastPlayerMove.piece === currentMove.piece) {
                const colorToPenalize = this.isRedTurn ? 'red' : 'black';
                this.scores[colorToPenalize]--;
            }

            if (this.isRedTurn) {
                this.lastMove.red = currentMove;
            } else {
                this.lastMove.black = currentMove;
            }

            this.board[to] = { ...this.board[from] };
            this.board[from] = { piece: null, isFlipped: true };
            this.switchTurn();
            return { type: 'move', from, to };
        }

        switchTurn() {
            this.isRedTurn = !this.isRedTurn;
            this.checkGameOver();
        }

        checkGameOver() {
            if (!this.isGameStarted || this.humanPlayerColor === null) return;

            let hasLegalAction = false;
            if (this.board.some(cell => !cell.isFlipped)) {
                hasLegalAction = true;
            }

            if (!hasLegalAction) {
                for (let i = 0; i < this.SQUARES; i++) {
                    const cell = this.board[i];
                    if (cell.piece && this.isPieceOfCurrentTurn(cell.piece)) {
                        if (this.getValidMoves(this.board, cell.piece, i).length > 0) {
                            hasLegalAction = true;
                            break;
                        }
                    }
                }
            }
            
            if (!hasLegalAction) {
                this.isGameOver = true;
            }
        }
        
        getScores() {
            let redScore = 0, blackScore = 0;
            this.board.forEach(cell => {
                if(cell.isFlipped && cell.piece) {
                    const score = this.scores[cell.piece.toLowerCase()];
                    if(this.isRedPiece(cell.piece)) redScore += score;
                    else blackScore += score;
                }
            });
            redScore += this.scores.red || 0;
            blackScore += this.scores.black || 0;
            return { redScore, blackScore };
        }

        getValidMoves(boardState, piece, index) {
            const legalMoves = [];
            const r = Math.floor(index / this.COLS);
            const c = index % this.COLS;
            const pieceIsRed = this.isRedPiece(piece);

            const isOnBoard = (row, col) => row >= 0 && row < this.ROWS && col >= 0 && col < this.COLS;
            const getIndex = (row, col) => row * this.COLS + col;

            switch (piece.toLowerCase()) {
                case 's': 
                    [[-1,0],[1,0],[0,-1],[0,1]].forEach(([rd,cd]) => {
                        if(isOnBoard(r+rd, c+cd)){
                            const targetIndex = getIndex(r+rd, c+cd);
                            const targetCell = boardState[targetIndex];
                            if(targetCell.isFlipped && (!targetCell.piece || pieceIsRed !== this.isRedPiece(targetCell.piece))) {
                                legalMoves.push(targetIndex);
                            }
                        }
                    });
                    break;
                
                case 'w': 
                    const archerMoveDirs = [[-1, 0], [1, 0], [0, -1], [0, 1]];
                    const archerCaptureDirs = [[-2,0],[2,0],[0,-2],[0,2],[-2,-2],[-2,2],[2,-2],[2,2]];
                    archerMoveDirs.forEach(([rd, cd]) => {
                        if (isOnBoard(r+rd, c+cd)) {
                            const targetIndex = getIndex(r+rd, c+cd);
                            const targetCell = boardState[targetIndex];
                            if (targetCell.isFlipped && !targetCell.piece) {
                                legalMoves.push(targetIndex);
                            }
                        }
                    });
                    archerCaptureDirs.forEach(([rd,cd]) => {
                         if(isOnBoard(r+rd, c+cd)){
                            const targetIndex = getIndex(r+rd, c+cd);
                            const targetCell = boardState[targetIndex];
                            if(targetCell.isFlipped && targetCell.piece && this.isRedPiece(targetCell.piece) !== pieceIsRed) {
                                legalMoves.push(targetIndex);
                            }
                        }
                    });
                    break;

                case 'k':
                    [[-1,0],[1,0],[0,-1],[0,1],[-1,-1],[-1,1],[1,-1],[1,1]].forEach(([rd,cd]) => {
                         if(isOnBoard(r+rd, c+cd)){
                            const targetIndex = getIndex(r+rd, c+cd);
                            const targetCell = boardState[targetIndex];
                            if(targetCell.isFlipped && (!targetCell.piece || pieceIsRed !== this.isRedPiece(targetCell.piece))) {
                                legalMoves.push(targetIndex);
                            }
                        }
                    });
                    break;

                case 'a':
                    const straightDirs = [[-1, 0], [1, 0], [0, -1], [0, 1]];
                    const diagonalDirs = [[-1, -1], [-1, 1], [1, -1], [1, 1]];
                    straightDirs.forEach(([rd, cd]) => {
                        if (isOnBoard(r + rd, c + cd)) {
                            const targetIndex = getIndex(r + rd, c + cd);
                            const targetCell = boardState[targetIndex];
                            if (targetCell.isFlipped && !targetCell.piece) {
                                legalMoves.push(targetIndex);
                            }
                        }
                    });
                    diagonalDirs.forEach(([rd, cd]) => {
                        if (isOnBoard(r + rd, c + cd)) {
                            const targetIndex = getIndex(r + rd, c + cd);
                            const targetCell = boardState[targetIndex];
                            if (targetCell.isFlipped && (!targetCell.piece || pieceIsRed !== this.isRedPiece(targetCell.piece))) {
                                legalMoves.push(targetIndex);
                            }
                        }
                    });
                    break;
                
                case 'e': 
                    [[-1,-1],[-1,1],[1,-1],[1,1]].forEach(([rd,cd]) => {
                        let temp_r = r + rd, temp_c = c + cd;
                        while(isOnBoard(temp_r, temp_c)){
                            const i = getIndex(temp_r, temp_c);
                            if(!boardState[i].isFlipped) break;
                            if(boardState[i].piece){
                                if(this.isRedPiece(boardState[i].piece) !== pieceIsRed) legalMoves.push(i);
                                break;
                            }
                            legalMoves.push(i);
                            temp_r += rd; temp_c += cd;
                        }
                    });
                    break;
                
                case 'h': 
                    [[-2,-1],[-2,1],[-1,-2],[-1,2],[1,-2],[1,2],[2,-1],[2,1]].forEach(([rd,cd]) => {
                         if(isOnBoard(r+rd, c+cd)){
                            const targetIndex = getIndex(r+rd, c+cd);
                            const targetCell = boardState[targetIndex];
                            if(targetCell.isFlipped && (!targetCell.piece || pieceIsRed !== this.isRedPiece(targetCell.piece))) {
                                legalMoves.push(targetIndex);
                            }
                        }
                    });
                    break;

                case 'r':
                    [[-1,0],[1,0],[0,-1],[0,1]].forEach(([rd,cd]) => {
                        let temp_r = r + rd, temp_c = c + cd;
                        while(isOnBoard(temp_r, temp_c)){
                            const i = getIndex(temp_r, temp_c);
                            if(!boardState[i].isFlipped) break;
                            if(boardState[i].piece){
                                if(this.isRedPiece(boardState[i].piece) !== pieceIsRed) legalMoves.push(i);
                                break;
                            }
                            legalMoves.push(i);
                            temp_r += rd; temp_c += cd;
                        }
                    });
                    break;
                
                case 'c':
                    [[-1,0],[1,0],[0,-1],[0,1]].forEach(([rd,cd]) => {
                        let temp_r = r + rd, temp_c = c + cd;
                        let screenFound = false;
                        while(isOnBoard(temp_r, temp_c)){
                            const i = getIndex(temp_r, temp_c);
                            const currentCell = boardState[i];
                            if(currentCell.piece){
                                if(!screenFound){
                                    screenFound = true; 
                                } else { 
                                    if(currentCell.isFlipped && this.isRedPiece(currentCell.piece) !== pieceIsRed){
                                        legalMoves.push(i);
                                    }
                                    break; 
                                }
                            } else {
                                if (!screenFound && currentCell.isFlipped) {
                                    legalMoves.push(i);
                                }
                            }
                            temp_r += rd; temp_c += cd;
                        }
                    });
                    break;
            }
            return legalMoves;
        }
    }

    // ===================================================================================
    // AI PLAYER (with Minimax)
    // ===================================================================================
    class AIPlayer {
        constructor(game) {
            this.game = game;
            this.SEARCH_DEPTH = 2; 
        }

        evaluateBoard(board) {
            let score = 0;
            board.forEach(cell => {
                if (cell.piece && cell.isFlipped) {
                    const pieceScore = this.game.scores[cell.piece.toLowerCase()];
                    score += this.game.isRedPiece(cell.piece) ? pieceScore : -pieceScore;
                }
            });
            return score;
        }

        minimax(board, depth, isMaximizingPlayer) {
            if (depth === 0) {
                return this.evaluateBoard(board);
            }

            const allPossibleMoves = [];
            for (let i = 0; i < this.game.SQUARES; i++) {
                const cell = board[i];
                if (cell.piece && cell.isFlipped && (this.game.isRedPiece(cell.piece) === isMaximizingPlayer)) {
                    const moves = this.game.getValidMoves(board, cell.piece, i);
                    moves.forEach(move => {
                        allPossibleMoves.push({ from: i, to: move });
                    });
                }
            }

            if (allPossibleMoves.length === 0) {
                return this.evaluateBoard(board);
            }

            if (isMaximizingPlayer) {
                let maxEval = -Infinity;
                for (const move of allPossibleMoves) {
                    const tempBoard = JSON.parse(JSON.stringify(board));
                    tempBoard[move.to] = { ...tempBoard[move.from] };
                    tempBoard[move.from] = { piece: null, isFlipped: true };
                    const evaluation = this.minimax(tempBoard, depth - 1, false);
                    maxEval = Math.max(maxEval, evaluation);
                }
                return maxEval;
            } else {
                let minEval = Infinity;
                for (const move of allPossibleMoves) {
                    const tempBoard = JSON.parse(JSON.stringify(board));
                    tempBoard[move.to] = { ...tempBoard[move.from] };
                    tempBoard[move.from] = { piece: null, isFlipped: true };
                    const evaluation = this.minimax(tempBoard, depth - 1, true);
                    minEval = Math.min(minEval, evaluation);
                }
                return minEval;
            }
        }

        findBestMove() {
            let bestScore = -Infinity;
            let bestMove = null;
            const aiIsRed = this.game.isRedTurn;

            for (let i = 0; i < this.game.SQUARES; i++) {
                const cell = this.game.board[i];
                if (cell.piece && cell.isFlipped && this.game.isPieceOfCurrentTurn(cell.piece)) {
                    const moves = this.game.getValidMoves(this.game.board, cell.piece, i);
                    for (const move of moves) {
                        const tempBoard = JSON.parse(JSON.stringify(this.game.board));
                        tempBoard[move] = { ...tempBoard[i] };
                        tempBoard[i] = { piece: null, isFlipped: true };
                        
                        const score = this.minimax(tempBoard, this.SEARCH_DEPTH - 1, !aiIsRed);
                        
                        let currentScore = aiIsRed ? score : -score;

                        if (currentScore > bestScore) {
                            bestScore = currentScore;
                            bestMove = { type: 'move', from: i, to: move };
                        }
                    }
                }
            }
            
            if (bestMove) {
                return bestMove;
            }

            const unflippedIndices = [];
            this.game.board.forEach((cell, index) => {
                if (!cell.isFlipped) unflippedIndices.push(index);
            });

            if (unflippedIndices.length > 0) {
                const randomFlipIndex = unflippedIndices[Math.floor(Math.random() * unflippedIndices.length)];
                return { type: 'flip', from: randomFlipIndex, to: randomFlipIndex };
            }

            return null;
        }
    }

    // ===================================================================================
    // UI CONTROLLER (The "Body")
    // ===================================================================================
    class GameUI {
        constructor() {
            this.game = new HiddenDragonGame();
            this.ai = new AIPlayer(this.game);
            this.boardElement = document.getElementById('chess-board');
            this.p1ScoreEl = document.getElementById('player1-score');
            this.p2ScoreEl = document.getElementById('player2-score');
            this.p1TitleEl = document.getElementById('p1-title');
            this.p2TitleEl = document.getElementById('p2-title');
            this.gameStatusEl = document.getElementById('game-status');
            this.gameOverEl = document.getElementById('game-over');
            this.resetButton = document.getElementById('reset-button');
            this.p1InfoEl = document.getElementById('player1-info');
            this.p2InfoEl = document.getElementById('player2-info');
            this.pregameOverlay = document.getElementById('pregame-overlay');
            this.humanFirstBtn = document.getElementById('human-first-btn');
            this.aiFirstBtn = document.getElementById('ai-first-btn');
            this.winnerOverlay = document.getElementById('winner-overlay');
            this.winnerText = document.getElementById('winner-text');
            
            this.pieceDisplay = {'k': { red: '帥', black: '將' }, 'a': { red: '士', black: '仕' }, 'e': { red: '相', black: '象' }, 'h': { red: '傌', black: '馬' }, 'r': { red: '車', black: '車' }, 'c': { red: '砲', black: '炮' }, 's': { red: '兵', black: '卒' }, 'w': { red: '弩', black: '弓' }};
            
            this.selectedPieceIndex = null;
            this.validMoves = [];
            this.isTurnInProgress = false;
            this.humanGoesFirst = true;

            this.resetButton.addEventListener('click', () => this.initialize());
            this.humanFirstBtn.addEventListener('click', () => this.startGame(true));
            this.aiFirstBtn.addEventListener('click', () => this.startGame(false));
            this.winnerOverlay.addEventListener('click', () => this.initialize());
            this.initialize();
        }

        initialize() {
            this.game.reset();
            this.selectedPieceIndex = null;
            this.validMoves = [];
            this.isTurnInProgress = false;
            this.winnerOverlay.classList.add('hidden');
            this.winnerOverlay.classList.remove('flex');
            this.pregameOverlay.classList.remove('hidden');
            this.pregameOverlay.classList.add('flex');
            this.updatePlayerUI();
            this.renderBoard();
        }

        startGame(humanFirst) {
            this.humanGoesFirst = humanFirst;
            this.pregameOverlay.classList.add('hidden');
            this.pregameOverlay.classList.remove('flex');
            
            if (humanFirst) {
                this.gameStatusEl.textContent = 'Your turn: Flip a piece to begin!';
            } else {
                this.gameStatusEl.textContent = 'AI is making the first move...';
                this.isTurnInProgress = true;
                setTimeout(() => {
                    const firstFlipIndex = Math.floor(Math.random() * this.game.SQUARES);
                    this.game.handleFirstFlip(firstFlipIndex, false);
                    this.renderBoard();
                    this.updatePlayerUI();
                    this.isTurnInProgress = false;
                }, 1000);
            }
        }

        renderBoard() {
            this.boardElement.innerHTML = '';
            for (let i = 0; i < this.game.SQUARES; i++) {
                const square = document.createElement('div');
                square.className = 'square flex items-center justify-center box-border border border-[#b38b5d] cursor-pointer';
                
                const cell = this.game.board[i];
                const pieceSpan = document.createElement('span');
                pieceSpan.className = 'piece w-[60px] h-[60px] rounded-full flex items-center justify-center text-4xl font-bold shadow-md';

                if (!cell.isFlipped) {
                    pieceSpan.classList.add('hidden-piece', 'bg-[#4a779c]', 'border-2', 'border-[#2e4a60]');
                } else if (cell.piece) {
                    const pieceColorClass = this.game.isRedPiece(cell.piece) ? 'red-piece' : 'black-piece';
                    pieceSpan.classList.add(pieceColorClass, 'bg-[#f0d5b1]');
                    const pieceType = cell.piece.toLowerCase();
                    const isRed = this.game.isRedPiece(cell.piece);
                    pieceSpan.textContent = this.pieceDisplay[pieceType][isRed ? 'red' : 'black'];
                }
                square.appendChild(pieceSpan);

                if (this.selectedPieceIndex === i) {
                    square.classList.add('bg-[#55a630!important]', 'border-2', 'border-[#386641]');
                }
                if (this.validMoves.includes(i)) {
                    square.classList.add('valid-move');
                }

                square.addEventListener('click', () => this.onSquareClick(i));
                this.boardElement.appendChild(square);
            }
        }

        onSquareClick(index) {
            if (this.game.isGameOver || this.isTurnInProgress) return;
            
            if (this.game.isGameStarted && !this.isHumanTurnNow()) return;

            if (!this.game.isGameStarted) {
                this.isTurnInProgress = true;
                this.game.handleFirstFlip(index, this.humanGoesFirst);
                this.renderBoard();
                setTimeout(() => {
                    this.isTurnInProgress = false;
                    this.updatePlayerUI();
                    this.checkForAITurn();
                }, 500);
                return;
            }

            const clickedCell = this.game.board[index];

            if (this.selectedPieceIndex !== null) {
                if (this.validMoves.includes(index)) {
                    this.game.handleMove(this.selectedPieceIndex, index);
                    this.selectedPieceIndex = null;
                    this.validMoves = [];
                    this.updatePlayerUI();
                    this.renderBoard();
                    this.checkForAITurn();
                } else {
                    this.selectedPieceIndex = null;
                    this.validMoves = [];
                    this.renderBoard();
                }
                return;
            }
            
            if (!clickedCell.isFlipped) {
                this.isTurnInProgress = true;
                this.game.handleFlip(index);
                this.renderBoard();
                setTimeout(() => {
                    this.isTurnInProgress = false;
                    this.updatePlayerUI();
                    this.checkForAITurn();
                }, 500);
                return;
            }

            if (clickedCell.piece && this.game.isPieceOfCurrentTurn(clickedCell.piece)) {
                this.selectedPieceIndex = index;
                this.validMoves = this.game.getValidMoves(this.game.board, clickedCell.piece, index);
                this.renderBoard();
            }
        }
        
        isHumanTurnNow() {
            if (!this.game.isGameStarted) return this.humanGoesFirst;
            return this.game.isRedPiece(this.game.humanPlayerColor) === this.game.isRedTurn;
        }

        checkForAITurn() {
            if (this.game.isGameOver) return;
            
            if (!this.isHumanTurnNow()) {
                this.isTurnInProgress = true;
                this.gameStatusEl.textContent = "AI is thinking...";
                setTimeout(() => {
                    const move = this.ai.findBestMove();
                    if (move) {
                        if (move.type === 'flip') {
                            this.game.handleFlip(move.from);
                        } else {
                            this.game.handleMove(move.from, move.to);
                        }
                    } else {
                        this.game.checkGameOver();
                    }
                    this.updatePlayerUI();
                    this.renderBoard();
                    this.isTurnInProgress = false;
                }, 1000); 
            }
        }

        updatePlayerUI() {
            const currentTurnColor = this.game.isRedTurn ? 'Red' : 'Black';
            const flippedCount = this.game.board.filter(c => c.isFlipped).length;
            this.gameStatusEl.innerHTML = `${currentTurnColor}'s Turn <br> (Flipped: ${flippedCount} / 32)`;
             
            if (this.game.humanPlayerColor) {
                const humanDisplayColor = this.game.humanPlayerColor === 'red' ? 'Red' : 'Black';
                const aiDisplayColor = this.game.humanPlayerColor === 'red' ? 'Black' : 'Red';
                
                // **MODIFIED**: Update titles and colors
                this.p1TitleEl.textContent = `Human (${humanDisplayColor})`;
                this.p2TitleEl.textContent = `AI (${aiDisplayColor})`;
                
                this.p1TitleEl.classList.remove('text-red-600', 'text-gray-800');
                this.p2TitleEl.classList.remove('text-red-600', 'text-gray-800');

                this.p1TitleEl.classList.add(humanDisplayColor === 'Red' ? 'text-red-600' : 'text-gray-800');
                this.p2TitleEl.classList.add(aiDisplayColor === 'Red' ? 'text-red-600' : 'text-gray-800');
                
            } else {
                 this.p1TitleEl.textContent = 'Player 1 (Human)';
                 this.p2TitleEl.textContent = 'Player 2 (AI)';
                 this.p1TitleEl.classList.remove('text-red-600', 'text-gray-800');
                 this.p2TitleEl.classList.remove('text-red-600', 'text-gray-800');
            }

            const scores = this.game.getScores();
            const humanIsRed = this.game.humanPlayerColor === 'red';
            this.p1ScoreEl.textContent = `Score: ${humanIsRed ? scores.redScore : scores.blackScore}`;
            this.p2ScoreEl.textContent = `Score: ${humanIsRed ? scores.blackScore : scores.redScore}`;

            const isHumanTurn = this.isHumanTurnNow();
            this.p1InfoEl.classList.toggle('active', isHumanTurn);
            this.p2InfoEl.classList.toggle('active', !isHumanTurn);
            
            if (this.game.isGameOver) {
                const finalScores = this.game.getScores();
                const humanFinalScore = this.game.humanPlayerColor === 'red' ? finalScores.redScore : finalScores.blackScore;
                const aiFinalScore = this.game.humanPlayerColor === 'red' ? finalScores.blackScore : finalScores.redScore;
                
                let winnerMessage = '';
                if (humanFinalScore > aiFinalScore) winnerMessage = "You Win!";
                else if (aiFinalScore > humanFinalScore) winnerMessage = "AI Wins!";
                else winnerMessage = "It's a Draw!";
                
                this.winnerText.innerHTML = `${winnerMessage}<br><span class="text-2xl mt-4 font-normal">(Click to play again)</span>`;
                this.winnerOverlay.classList.remove('hidden');
                this.winnerOverlay.classList.add('flex');
                
                this.gameOverEl.textContent = `Game Over! Final scores are calculated.`;
                this.gameStatusEl.textContent = '';
            } else {
                this.gameOverEl.textContent = '';
            }
        }
    }

    new GameUI();
</script>
</body>
</html>
